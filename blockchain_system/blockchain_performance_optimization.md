1、针对“Hyperledger Fabric中的solo模式和内存模式”的一点浅显思考

Fabric在发布之初，排序算法就包含solo和kafak两种模式。后来v1.4.1版本引入raft算法。为什么会有solo呢？我想到了几个理由。

首先，对orderer服务而言，在生产部署solo是几乎不可能的（例如，中心化、单点故障）；那最有可能的就是方便开发&调试（例如，peer开发完毕，想端到端的跑一笔交易），但solo更隐含的好处是性能测试。一般地，一个系统在单机上的表现会受到机器的CPU核数、网络带宽大小、磁盘IOPS等外部限制。抛开这些限制，如果我们想深层次探究，我们的程序到底慢在哪里了？哪个模块最耗cpu时间？或者在我们识别瓶颈后，并完成优化，想要度量该模块的优化效果时，我们希望尽量在真实的负载下取得性能数据。为了不让网络带宽成为瓶颈，我们可以选择solo模式（raft也支持单orderer）。

同理，在早期fabric orderer侧的账本实现中，支持内存模式。这在度量共识服务本身的吞吐量时候是有用的，这避免磁盘IO成为瓶颈。当然想度量共识服务本身的天花板，可以将共识集群部署在一个数据中心，从而避免网络带宽成为瓶颈。此外，还要避免压测工具的瓶颈，可以采用多机分布式压测。

不仅fabric orderer侧的账本可以支持内存模式，fabric peer侧的账本也可以支持内存模式。可以用来对peer的某些模块进行性能量化。例如，交易背书校验和提交。